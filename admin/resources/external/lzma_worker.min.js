var LZMA = function() {
    "use strict";
    var t = 3,
        u = "function" == typeof setImmediate ? setImmediate : setTimeout,
        n = 4294967296,
        c = [4294967295, -n],
        o = [0, -0x8000000000000000],
        h = [0, 0],
        P = [1, 0];

    function f(e, r) {
        postMessage({
            action: t,
            cbn: r,
            result: e
        })
    }

    function m(e) {
        var r = [];
        return r[e - 1] = void 0, r
    }

    function l(e, r) {
        return s(e[0] + r[0], e[1] + r[1])
    }

    function i(e, r) {
        return function(e, r) {
            (r = r) < 0 && (r += n);
            return [r, e * n]
        }(~~Math.max(Math.min(e[1] / n, 2147483647), -2147483648) & ~~Math.max(Math.min(r[1] / n, 2147483647), -2147483648), g(e) & g(r))
    }

    function v(e, r) {
        var t, o;
        return e[0] == r[0] && e[1] == r[1] ? 0 : (t = e[1] < 0, o = r[1] < 0, t && !o || (t || !o) && k(e, r)[1] < 0 ? -1 : 1)
    }

    function s(e, r) {
        var t, o;
        for (e %= 0x10000000000000000, r = (r %= 0x10000000000000000) - (t = r % n) + (o = Math.floor(e / n) * n), e = e - o + t; e < 0;) e += n, r -= n;
        for (; 4294967295 < e;) e -= n, r += n;
        for (r %= 0x10000000000000000; 0x7fffffff00000000 < r;) r -= 0x10000000000000000;
        for (; r < -0x8000000000000000;) r += 0x10000000000000000;
        return [e, r]
    }

    function B(e, r) {
        return e[0] == r[0] && e[1] == r[1]
    }

    function S(e) {
        return 0 <= e ? [e, 0] : [e + n, -n]
    }

    function g(e) {
        return 2147483648 <= e[0] ? ~~Math.max(Math.min(e[0] - n, 2147483647), -2147483648) : ~~Math.max(Math.min(e[0], 2147483647), -2147483648)
    }

    function _(e) {
        return e <= 30 ? 1 << e : _(30) * _(e - 30)
    }

    function a(e, r) {
        var t;
        if (r &= 63, B(e, o)) return r ? h : e;
        if (e[1] < 0) throw new Error("Neg");
        return t = _(r), r = e[1] * t % 0x10000000000000000, 0x8000000000000000 <= (r += t = (e = e[0] * t) - e % n) && (r -= 0x10000000000000000), [e -= t, r]
    }

    function d(e, r) {
        r = _(r &= 63);
        return s(Math.floor(e[0] / r), e[1] / r)
    }

    function k(e, r) {
        return s(e[0] - r[0], e[1] - r[1])
    }

    function p(e, r) {
        return e.buf = r, e.pos = 0, e.count = r.length, e
    }

    function R(e) {
        return e.pos >= e.count ? -1 : 255 & e.buf[e.pos++]
    }

    function M(e) {
        return e.buf = m(32), e.count = 0, e
    }

    function D(e) {
        var r = e.buf;
        return r.length = e.count, r
    }

    function b(e, r) {
        e.buf[e.count++] = r << 24 >> 24
    }

    function w(e, r, t, o) {
        E(r, t, e.buf, e.count, o), e.count += o
    }

    function E(e, r, t, o, n) {
        for (var s = 0; s < n; ++s) t[o + s] = e[r + s]
    }

    function y(e, r) {
        var t, o;
        ! function(e, r) {
            e._dictionarySize = r;
            for (var t = 0; 1 << t < r; ++t);
            e._distTableSize = 2 * t
        }(r, 1 << e.s), r._numFastBytes = e.f, t = r, o = e.m, e = t._matchFinderType, t._matchFinderType = o, t._matchFinder && e != t._matchFinderType && (t._dictionarySizePrev = -1, t._matchFinder = null), r._numLiteralPosStateBits = 0, r._numLiteralContextBits = 3, r._posStateBits = 2, r._posStateMask = 3
    }

    function C(e, r, t, o, n) {
        var s;
        if (v(o, c) < 0) throw new Error("invalid length " + o);
        for (e.length_0 = o, y(n, n = function(e) {
                var r;
                for (e._repDistances = m(4), e._optimum = [], e._rangeEncoder = {}, e._isMatch = m(192), e._isRep = m(12), e._isRepG0 = m(12), e._isRepG1 = m(12), e._isRepG2 = m(12), e._isRep0Long = m(192), e._posSlotEncoder = [], e._posEncoders = m(114), e._posAlignEncoder = ke({}, 4), e._lenEncoder = de({}), e._repMatchLenEncoder = de({}), e._literalEncoder = {}, e._matchDistances = [], e._posSlotPrices = [], e._distancesPrices = [], e._alignPrices = m(16), e.reps = m(4), e.repLens = m(4), e.processedInSize = [h], e.processedOutSize = [h], e.finished = [0], e.properties = m(5), e.tempPrices = m(128), e._longestMatchLength = 0, e._matchFinderType = 1, e._numDistancePairs = 0, e._numFastBytesPrev = -1, e.backRes = 0, r = 0; r < 4096; ++r) e._optimum[r] = {};
                for (r = 0; r < 4; ++r) e._posSlotEncoder[r] = ke({}, 6);
                return e
            }({})), n._writeEndMark = void 0 === LZMA.disableEndMark, function(e, r) {
                e.properties[0] = 9 * (5 * e._posStateBits + e._numLiteralPosStateBits) + e._numLiteralContextBits << 24 >> 24;
                for (var t = 0; t < 4; ++t) e.properties[1 + t] = e._dictionarySize >> 8 * t << 24 >> 24;
                w(r, e.properties, 0, 5)
            }(n, t), s = 0; s < 64; s += 8) b(t, 255 & g(d(o, s)));
        e.chunker = (n._needReleaseMFStream = 0, n._inStream = r, n._finished = 0, function(e) {
            var r, t;
            e._matchFinder || (r = {}, t = 4, e._matchFinderType || (t = 2), function(e, r) {
                e.HASH_ARRAY = 2 < r, e.HASH_ARRAY ? (e.kNumHashDirectBytes = 0, e.kMinMatchCheck = 4, e.kFixHashSize = 66560) : (e.kNumHashDirectBytes = 2, e.kMinMatchCheck = 3, e.kFixHashSize = 0)
            }(r, t), e._matchFinder = r);
            if (function(e, r, t) {
                    var o, n;
                    if (null != e.m_Coders && e.m_NumPrevBits == t && e.m_NumPosBits == r) return;
                    for (e.m_NumPosBits = r, e.m_PosMask = (1 << r) - 1, e.m_NumPrevBits = t, n = 1 << e.m_NumPrevBits + e.m_NumPosBits, e.m_Coders = m(n), o = 0; o < n; ++o) e.m_Coders[o] = function(e) {
                        return e.m_Encoders = m(768), e
                    }({})
                }(e._literalEncoder, e._numLiteralPosStateBits, e._numLiteralContextBits), e._dictionarySize == e._dictionarySizePrev && e._numFastBytesPrev == e._numFastBytes) return;
            (function(e, r, t, o, n) {
                r < 1073741567 && (e._cutValue = 16 + (o >> 1), function(e, r, t, o) {
                    e._keepSizeBefore = r, e._keepSizeAfter = t, o = r + t + o, null != e._bufferBase && e._blockSize == o || (e._bufferBase = null, e._blockSize = o, e._bufferBase = m(e._blockSize));
                    e._pointerToLastSafePosition = e._blockSize - t
                }(e, r + t, o + n, 256 + ~~((r + t + o + n) / 2)), e._matchMaxLen = o, o = r + 1, e._cyclicBufferSize != o && (e._son = m(2 * (e._cyclicBufferSize = o))), o = 65536, e.HASH_ARRAY && (o = r - 1, o |= o >> 1, o |= o >> 2, o |= o >> 4, o |= o >> 8, o >>= 1, 16777216 < (o |= 65535) && (o >>= 1), e._hashMask = o, ++o, o += e.kFixHashSize), o != e._hashSizeSum && (e._hash = m(e._hashSizeSum = o)))
            })(e._matchFinder, e._dictionarySize, 4096, e._numFastBytes, 274), e._dictionarySizePrev = e._dictionarySize, e._numFastBytesPrev = e._numFastBytes
        }(n), n._rangeEncoder.Stream = t, function(e) {
            (function(e) {
                e._state = 0;
                for (var r = e._previousByte = 0; r < 4; ++r) e._repDistances[r] = 0
            })(e),
            function(e) {
                e._position = h, e.Low = h, e.Range = -1, e._cacheSize = 1, e._cache = 0
            }(e._rangeEncoder), we(e._isMatch), we(e._isRep0Long), we(e._isRep), we(e._isRepG0), we(e._isRepG1), we(e._isRepG2), we(e._posEncoders),
                function(e) {
                    var r, t = 1 << e.m_NumPrevBits + e.m_NumPosBits;
                    for (r = 0; r < t; ++r) we(e.m_Coders[r].m_Encoders)
                }(e._literalEncoder);
            for (var r = 0; r < 4; ++r) we(e._posSlotEncoder[r].Models);
            ue(e._lenEncoder, 1 << e._posStateBits), ue(e._repMatchLenEncoder, 1 << e._posStateBits), we(e._posAlignEncoder.Models), e._longestMatchWasFound = 0, e._optimumEndIndex = 0, e._optimumCurrentIndex = 0, e._additionalOffset = 0
        }(n), te(n), re(n), n._lenEncoder._tableSize = n._numFastBytes + 1 - 2, he(n._lenEncoder, 1 << n._posStateBits), n._repMatchLenEncoder._tableSize = n._numFastBytes + 1 - 2, he(n._repMatchLenEncoder, 1 << n._posStateBits), n.nowPos64 = h, (r = {}).encoder = n, r.decoder = null, r.alive = 1, r)
    }

    function L(e, r, t) {
        return e.output = M({}), C(e, p({}, r), e.output, S(r.length), t), e
    }

    function z(e, r, t) {
        for (var o, n, s, i = "", _ = [], a = 0; a < 5; ++a) {
            if (-1 == (o = R(r))) throw new Error("truncated input");
            _[a] = o << 24 >> 24
        }
        if (! function(e, r) {
                var t, o, n, s, i;
                if (r.length < 5) return 0;
                for (i = 255 & r[0], n = i % 9, i = (s = ~~(i / 9)) % 5, s = ~~(s / 5), o = t = 0; o < 4; ++o) t += (255 & r[1 + o]) << 8 * o;
                if (99999999 < t || ! function(e, r, t, o) {
                        if (8 < r || 4 < t || 4 < o) return 0;
                        ! function(e, r, t) {
                            var o, n;
                            if (null != e.m_Coders && e.m_NumPrevBits == t && e.m_NumPosBits == r) return;
                            for (e.m_NumPosBits = r, e.m_PosMask = (1 << r) - 1, e.m_NumPrevBits = t, n = 1 << e.m_NumPrevBits + e.m_NumPosBits, e.m_Coders = m(n), o = 0; o < n; ++o) e.m_Coders[o] = function(e) {
                                return e.m_Decoders = m(768), e
                            }({})
                        }(e.m_LiteralDecoder, t, r);
                        o = 1 << o;
                        return q(e.m_LenDecoder, o), q(e.m_RepLenDecoder, o), e.m_PosStateMask = o - 1, 1
                    }(e, n, i, s)) return 0;
                return function(e, r) {
                    if (r < 0) return 0;
                    e.m_DictionarySize != r && (e.m_DictionarySize = r, e.m_DictionarySizeCheck = Math.max(e.m_DictionarySize, 1), function(e, r) {
                        null != e._buffer && e._windowSize == r || (e._buffer = m(r));
                        e._windowSize = r, e._pos = 0, e._streamPos = 0
                    }(e.m_OutWindow, Math.max(e.m_DictionarySizeCheck, 4096)));
                    return 1
                }(e, t)
            }(s = function(e) {
                e.m_OutWindow = {}, e.m_RangeDecoder = {}, e.m_IsMatchDecoders = m(192), e.m_IsRepDecoders = m(12), e.m_IsRepG0Decoders = m(12), e.m_IsRepG1Decoders = m(12), e.m_IsRepG2Decoders = m(12), e.m_IsRep0LongDecoders = m(192), e.m_PosSlotDecoder = m(4), e.m_PosDecoders = m(114), e.m_PosAlignDecoder = Se({}, 4), e.m_LenDecoder = Q({}), e.m_RepLenDecoder = Q({}), e.m_LiteralDecoder = {};
                for (var r = 0; r < 4; ++r) e.m_PosSlotDecoder[r] = Se({}, 6);
                return e
            }({}), _)) throw new Error("corrupted input");
        for (a = 0; a < 64; a += 8) {
            if (-1 == (o = R(r))) throw new Error("truncated input");
            1 == (o = o.toString(16)).length && (o = "0" + o), i = o + "" + i
        }
        /^0+$|^f+$/i.test(i) ? e.length_0 = c : (n = parseInt(i, 16), e.length_0 = 4294967295 < n ? c : S(n)), e.chunker = (n = s, s = r, t = t, e = e.length_0, n.m_RangeDecoder.Stream = s, T(n.m_OutWindow), n.m_OutWindow._stream = t, function(e) {
            e.m_OutWindow._streamPos = 0, e.m_OutWindow._pos = 0, we(e.m_IsMatchDecoders), we(e.m_IsRep0LongDecoders), we(e.m_IsRepDecoders), we(e.m_IsRepG0Decoders), we(e.m_IsRepG1Decoders), we(e.m_IsRepG2Decoders), we(e.m_PosDecoders),
                function(e) {
                    var r, t;
                    for (t = 1 << e.m_NumPrevBits + e.m_NumPosBits, r = 0; r < t; ++r) we(e.m_Coders[r].m_Decoders)
                }(e.m_LiteralDecoder);
            for (var r = 0; r < 4; ++r) we(e.m_PosSlotDecoder[r].Models);
            U(e.m_LenDecoder), U(e.m_RepLenDecoder), we(e.m_PosAlignDecoder.Models),
                function(e) {
                    e.Code = 0, e.Range = -1;
                    for (var r = 0; r < 5; ++r) e.Code = e.Code << 8 | R(e.Stream)
                }(e.m_RangeDecoder)
        }(n), n.state = 0, n.rep0 = 0, n.rep1 = 0, n.rep2 = 0, n.rep3 = 0, n.outSize = e, n.nowPos64 = h, n.prevByte = 0, function(e, r) {
            return e.decoder = r, e.encoder = null, e.alive = 1, e
        }({}, n))
    }

    function F(e, r) {
        return e.output = M({}), z(e, p({}, r), e.output), e
    }

    function V(e, r) {
        return e._bufferBase[e._bufferOffset + e._pos + r]
    }

    function j(e, r, t, o) {
        var n, s;
        for (e._streamEndWasReached && e._pos + r + o > e._streamPos && (o = e._streamPos - (e._pos + r)), ++t, s = e._bufferOffset + e._pos + r, n = 0; n < o && e._bufferBase[s + n] == e._bufferBase[s + n - t]; ++n);
        return n
    }

    function $(e) {
        return e._streamPos - e._pos
    }

    function I(e) {
        ++e._pos, e._pos > e._posLimit && (e._bufferOffset + e._pos > e._pointerToLastSafePosition && function(e) {
            var r, t, o = e._bufferOffset + e._pos - e._keepSizeBefore;
            for (0 < o && --o, t = e._bufferOffset + e._streamPos - o, r = 0; r < t; ++r) e._bufferBase[r] = e._bufferBase[o + r];
            e._bufferOffset -= o
        }(e), x(e))
    }

    function x(e) {
        var r, t, o, n;
        if (!e._streamEndWasReached)
            for (;;) {
                if (!(n = -e._bufferOffset + e._blockSize - e._streamPos)) return;
                if (r = e._stream, t = e._bufferBase, o = e._bufferOffset + e._streamPos, n = n, -1 == (n = r.pos >= r.count ? -1 : (n = Math.min(n, r.count - r.pos), E(r.buf, r.pos, t, o, n), r.pos += n, n))) return e._posLimit = e._streamPos, e._bufferOffset + e._posLimit > e._pointerToLastSafePosition && (e._posLimit = e._pointerToLastSafePosition - e._bufferOffset), void(e._streamEndWasReached = 1);
                e._streamPos += n, e._streamPos >= e._pos + e._keepSizeAfter && (e._posLimit = e._streamPos - e._keepSizeAfter)
            }
    }

    function N(e, r) {
        e._bufferOffset += r, e._posLimit -= r, e._pos -= r, e._streamPos -= r
    }
    var O = function() {
        for (var e, r, t = [], o = 0; o < 256; ++o) {
            for (r = o, e = 0; e < 8; ++e) 0 != (1 & r) ? r = r >>> 1 ^ -306674912 : r >>>= 1;
            t[o] = r
        }
        return t
    }();

    function A(e) {
        var r;
        ++e._cyclicBufferPos >= e._cyclicBufferSize && (e._cyclicBufferPos = 0), I(e), 1073741823 == e._pos && (r = e._pos - e._cyclicBufferSize, H(e._son, 2 * e._cyclicBufferSize, r), H(e._hash, e._hashSizeSum, r), N(e, r))
    }

    function H(e, r, t) {
        for (var o, n = 0; n < r; ++n)(o = e[n] || 0) <= t ? o = 0 : o -= t, e[n] = o
    }

    function G(e) {
        var r = e._pos - e._streamPos;
        r && (w(e._stream, e._buffer, e._streamPos, r), e._pos >= e._windowSize && (e._pos = 0), e._streamPos = e._pos)
    }

    function W(e, r) {
        r = e._pos - r - 1;
        return r < 0 && (r += e._windowSize), e._buffer[r]
    }

    function T(e) {
        G(e), e._stream = null
    }

    function Z(e) {
        return (e -= 2) < 4 ? e : 3
    }

    function K(e) {
        return e < 4 ? 0 : e < 10 ? e - 3 : e - 6
    }

    function Y(e) {
        if (!e.alive) throw new Error("bad state");
        var r;
        return e.encoder ? (function(e, r, t, o) {
            var n, s, i, _, a, c, u, f, m, d, p;
            r[0] = h, t[0] = h, o[0] = 1, e._inStream && (e._matchFinder._stream = e._inStream, function(e) {
                e._bufferOffset = 0, e._pos = 0, e._streamPos = 0, e._streamEndWasReached = 0, x(e), e._cyclicBufferPos = 0, N(e, -1)
            }(e._matchFinder), e._needReleaseMFStream = 1, e._inStream = null);
            if (e._finished) return;
            if (e._finished = 1, d = e.nowPos64, B(e.nowPos64, h)) {
                if (!$(e._matchFinder)) return oe(e, g(e.nowPos64));
                _e(e), m = g(e.nowPos64) & e._posStateMask, ye(e._rangeEncoder, e._isMatch, (e._state << 4) + m, 0), e._state = K(e._state), s = V(e._matchFinder, -e._additionalOffset), le(Pe(e._literalEncoder, g(e.nowPos64), e._previousByte), e._rangeEncoder, s), e._previousByte = s, --e._additionalOffset, e.nowPos64 = l(e.nowPos64, P)
            }
            if (!$(e._matchFinder)) return oe(e, g(e.nowPos64));
            for (;;) {
                if (a = function(e, r) {
                        var t, o, n, s, i, _, a, c, u, f, m, d, p, h, P, l, v, B, S, g, k, R, M, D, b, w, E, y, C, L, z, F, I, x, N, O, A, H, G, W, T, Z, Y;
                        if (e._optimumEndIndex != e._optimumCurrentIndex) return p = e._optimum[e._optimumCurrentIndex].PosPrev - e._optimumCurrentIndex, e.backRes = e._optimum[e._optimumCurrentIndex].BackPrev, e._optimumCurrentIndex = e._optimum[e._optimumCurrentIndex].PosPrev, p;
                        e._optimumCurrentIndex = e._optimumEndIndex = 0, e._longestMatchWasFound ? (d = e._longestMatchLength, e._longestMatchWasFound = 0) : d = _e(e);
                        if (b = e._numDistancePairs, (M = $(e._matchFinder) + 1) < 2) return e.backRes = -1, 1;
                        273 < M && (M = 273);
                        for (u = H = 0; u < 4; ++u) e.reps[u] = e._repDistances[u], e.repLens[u] = j(e._matchFinder, -1, e.reps[u], 273), e.repLens[u] > e.repLens[H] && (H = u);
                        if (e.repLens[H] >= e._numFastBytes) return e.backRes = H, p = e.repLens[H], ie(e, p - 1), p;
                        if (d >= e._numFastBytes) return e.backRes = e._matchDistances[b - 1] + 4, ie(e, d - 1), d;
                        if (a = V(e._matchFinder, -1), v = V(e._matchFinder, -e._repDistances[0] - 1 - 1), d < 2 && a != v && e.repLens[H] < 2) return e.backRes = -1, 1;
                        e._optimum[0].State = e._state, F = r & e._posStateMask, e._optimum[1].Price = Ee[e._isMatch[(e._state << 4) + F] >>> 2] + ve(Pe(e._literalEncoder, r, e._previousByte), 7 <= e._state, v, a), Be(e._optimum[1]), B = Ee[2048 - e._isMatch[(e._state << 4) + F] >>> 2], A = B + Ee[2048 - e._isRep[e._state] >>> 2], v != a || (G = A + function(e, r, t) {
                            return Ee[e._isRepG0[r] >>> 2] + Ee[e._isRep0Long[(r << 4) + t] >>> 2]
                        }(e, e._state, F)) < e._optimum[1].Price && (e._optimum[1].Price = G, function(e) {
                            e.BackPrev = 0, e.Prev1IsChar = 0
                        }(e._optimum[1]));
                        if ((m = d >= e.repLens[H] ? d : e.repLens[H]) < 2) return e.backRes = e._optimum[1].BackPrev, 1;
                        e._optimum[1].PosPrev = 0, e._optimum[0].Backs0 = e.reps[0], e._optimum[0].Backs1 = e.reps[1], e._optimum[0].Backs2 = e.reps[2], e._optimum[0].Backs3 = e.reps[3], f = m;
                        for (; e._optimum[f--].Price = 268435455, 2 <= f;);
                        for (u = 0; u < 4; ++u)
                            if (!((O = e.repLens[u]) < 2))
                                for (x = A + se(e, u, e._state, F); s = x + pe(e._repMatchLenEncoder, O - 2, F), C = e._optimum[O], s < C.Price && (C.Price = s, C.PosPrev = 0, C.BackPrev = u, C.Prev1IsChar = 0), 2 <= --O;);
                        if (R = B + Ee[e._isRep[e._state] >>> 2], (f = 2 <= e.repLens[0] ? e.repLens[0] + 1 : 2) <= d) {
                            for (w = 0; f > e._matchDistances[w];) w += 2;
                            for (; c = e._matchDistances[w + 1], s = R + ne(e, c, f, F), C = e._optimum[f], s < C.Price && (C.Price = s, C.PosPrev = 0, C.BackPrev = c + 4, C.Prev1IsChar = 0), f != e._matchDistances[w] || (w += 2) != b; ++f);
                        }
                        t = 0;
                        for (;;) {
                            if (++t == m) return ee(e, t);
                            if (S = _e(e), b = e._numDistancePairs, S >= e._numFastBytes) return e._longestMatchLength = S, e._longestMatchWasFound = 1, ee(e, t);
                            if (++r, z = e._optimum[t].PosPrev, T = e._optimum[t].Prev1IsChar ? (--z, K(T = e._optimum[t].Prev2 ? (T = e._optimum[e._optimum[t].PosPrev2].State, e._optimum[t].BackPrev2 < 4 ? T < 7 ? 8 : 11 : T < 7 ? 7 : 10) : e._optimum[z].State)) : e._optimum[z].State, z == t - 1 ? T = e._optimum[t].BackPrev ? K(T) : T < 7 ? 9 : 11 : (T = e._optimum[t].Prev1IsChar && e._optimum[t].Prev2 ? (z = e._optimum[t].PosPrev2, L = e._optimum[t].BackPrev2, T < 7 ? 8 : 11) : (L = e._optimum[t].BackPrev) < 4 ? T < 7 ? 8 : 11 : T < 7 ? 7 : 10, y = e._optimum[z], L < 4 ? L ? 1 == L ? (e.reps[0] = y.Backs1, e.reps[1] = y.Backs0, e.reps[2] = y.Backs2, e.reps[3] = y.Backs3) : 2 == L ? (e.reps[0] = y.Backs2, e.reps[1] = y.Backs0, e.reps[2] = y.Backs1, e.reps[3] = y.Backs3) : (e.reps[0] = y.Backs3, e.reps[1] = y.Backs0, e.reps[2] = y.Backs1, e.reps[3] = y.Backs2) : (e.reps[0] = y.Backs0, e.reps[1] = y.Backs1, e.reps[2] = y.Backs2, e.reps[3] = y.Backs3) : (e.reps[0] = L - 4, e.reps[1] = y.Backs0, e.reps[2] = y.Backs1, e.reps[3] = y.Backs2)), e._optimum[t].State = T, e._optimum[t].Backs0 = e.reps[0], e._optimum[t].Backs1 = e.reps[1], e._optimum[t].Backs2 = e.reps[2], e._optimum[t].Backs3 = e.reps[3], _ = e._optimum[t].Price, a = V(e._matchFinder, -1), v = V(e._matchFinder, -e.reps[0] - 1 - 1), F = r & e._posStateMask, o = _ + Ee[e._isMatch[(T << 4) + F] >>> 2] + ve(Pe(e._literalEncoder, r, V(e._matchFinder, -2)), 7 <= T, v, a), z = e._optimum[t + 1], y = 0, o < z.Price && (z.Price = o, z.PosPrev = t, z.BackPrev = -1, z.Prev1IsChar = 0, y = 1), B = _ + Ee[2048 - e._isMatch[(T << 4) + F] >>> 2], A = B + Ee[2048 - e._isRep[T] >>> 2], v != a || z.PosPrev < t && !z.BackPrev || (G = A + (Ee[e._isRepG0[T] >>> 2] + Ee[e._isRep0Long[(T << 4) + F] >>> 2])) <= z.Price && (z.Price = G, z.PosPrev = t, z.BackPrev = 0, z.Prev1IsChar = 0, y = 1), D = $(e._matchFinder) + 1, !((M = D = 4095 - t < D ? 4095 - t : D) < 2)) {
                                if (M > e._numFastBytes && (M = e._numFastBytes), !y && v != a && (Y = Math.min(D - 1, e._numFastBytes), 2 <= (P = j(e._matchFinder, 0, e.reps[0], Y)))) {
                                    for (Z = K(T), I = r + 1 & e._posStateMask, k = o + Ee[2048 - e._isMatch[(Z << 4) + I] >>> 2] + Ee[2048 - e._isRep[Z] >>> 2], E = t + 1 + P; m < E;) e._optimum[++m].Price = 268435455;
                                    s = k + (pe(e._repMatchLenEncoder, P - 2, I) + se(e, 0, Z, I)), C = e._optimum[E], s < C.Price && (C.Price = s, C.PosPrev = t + 1, C.BackPrev = 0, C.Prev1IsChar = 1, C.Prev2 = 0)
                                }
                                for (W = 2, N = 0; N < 4; ++N)
                                    if (!((h = j(e._matchFinder, -1, e.reps[N], M)) < 2)) {
                                        l = h;
                                        do {
                                            for (; m < t + h;) e._optimum[++m].Price = 268435455;
                                            s = A + (pe(e._repMatchLenEncoder, h - 2, F) + se(e, N, T, F)), C = e._optimum[t + h], s < C.Price && (C.Price = s, C.PosPrev = t, C.BackPrev = N, C.Prev1IsChar = 0)
                                        } while (2 <= --h);
                                        if (h = l, N || (W = h + 1), h < D && (Y = Math.min(D - 1 - h, e._numFastBytes), 2 <= (P = j(e._matchFinder, h, e.reps[N], Y)))) {
                                            for (Z = T < 7 ? 8 : 11, I = r + h & e._posStateMask, n = A + (pe(e._repMatchLenEncoder, h - 2, F) + se(e, N, T, F)) + Ee[e._isMatch[(Z << 4) + I] >>> 2] + ve(Pe(e._literalEncoder, r + h, V(e._matchFinder, h - 1 - 1)), 1, V(e._matchFinder, h - 1 - (e.reps[N] + 1)), V(e._matchFinder, h - 1)), Z = K(Z), I = r + h + 1 & e._posStateMask, g = n + Ee[2048 - e._isMatch[(Z << 4) + I] >>> 2], k = g + Ee[2048 - e._isRep[Z] >>> 2], E = h + 1 + P; m < t + E;) e._optimum[++m].Price = 268435455;
                                            s = k + (pe(e._repMatchLenEncoder, P - 2, I) + se(e, 0, Z, I)), C = e._optimum[t + E], s < C.Price && (C.Price = s, C.PosPrev = t + h + 1, C.BackPrev = 0, C.Prev1IsChar = 1, C.Prev2 = 1, C.PosPrev2 = t, C.BackPrev2 = N)
                                        }
                                    }
                                if (M < S) {
                                    for (S = M, b = 0; S > e._matchDistances[b]; b += 2);
                                    e._matchDistances[b] = S, b += 2
                                }
                                if (W <= S) {
                                    for (R = B + Ee[e._isRep[T] >>> 2]; m < t + S;) e._optimum[++m].Price = 268435455;
                                    for (w = 0; W > e._matchDistances[w];) w += 2;
                                    for (h = W;; ++h)
                                        if (i = e._matchDistances[w + 1], s = R + ne(e, i, h, F), C = e._optimum[t + h], s < C.Price && (C.Price = s, C.PosPrev = t, C.BackPrev = i + 4, C.Prev1IsChar = 0), h == e._matchDistances[w]) {
                                            if (h < D && (Y = Math.min(D - 1 - h, e._numFastBytes), 2 <= (P = j(e._matchFinder, h, i, Y)))) {
                                                for (Z = T < 7 ? 7 : 10, I = r + h & e._posStateMask, n = s + Ee[e._isMatch[(Z << 4) + I] >>> 2] + ve(Pe(e._literalEncoder, r + h, V(e._matchFinder, h - 1 - 1)), 1, V(e._matchFinder, h - (i + 1) - 1), V(e._matchFinder, h - 1)), Z = K(Z), I = r + h + 1 & e._posStateMask, g = n + Ee[2048 - e._isMatch[(Z << 4) + I] >>> 2], k = g + Ee[2048 - e._isRep[Z] >>> 2], E = h + 1 + P; m < t + E;) e._optimum[++m].Price = 268435455;
                                                s = k + (pe(e._repMatchLenEncoder, P - 2, I) + se(e, 0, Z, I)), C = e._optimum[t + E], s < C.Price && (C.Price = s, C.PosPrev = t + h + 1, C.BackPrev = 0, C.Prev1IsChar = 1, C.Prev2 = 1, C.PosPrev2 = t, C.BackPrev2 = i + 4)
                                            }
                                            if ((w += 2) == b) break
                                        }
                                }
                            }
                        }
                    }(e, g(e.nowPos64)), u = e.backRes, m = g(e.nowPos64) & e._posStateMask, n = (e._state << 4) + m, 1 == a && -1 == u) ye(e._rangeEncoder, e._isMatch, n, 0), s = V(e._matchFinder, -e._additionalOffset), p = Pe(e._literalEncoder, g(e.nowPos64), e._previousByte), e._state < 7 ? le(p, e._rangeEncoder, s) : (c = V(e._matchFinder, -e._repDistances[0] - 1 - e._additionalOffset), function(e, r, t, o) {
                    var n, s, i, _, a = 1,
                        c = 1;
                    for (s = 7; 0 <= s; --s) n = o >> s & 1, _ = c, a && (_ += 1 + (i = t >> s & 1) << 8, a = i == n), ye(r, e.m_Encoders, _, n), c = c << 1 | n
                }(p, e._rangeEncoder, c, s)), e._previousByte = s, e._state = K(e._state);
                else {
                    if (ye(e._rangeEncoder, e._isMatch, n, 1), u < 4) {
                        if (ye(e._rangeEncoder, e._isRep, e._state, 1), u ? (ye(e._rangeEncoder, e._isRepG0, e._state, 1), 1 == u ? ye(e._rangeEncoder, e._isRepG1, e._state, 0) : (ye(e._rangeEncoder, e._isRepG1, e._state, 1), ye(e._rangeEncoder, e._isRepG2, e._state, u - 2))) : (ye(e._rangeEncoder, e._isRepG0, e._state, 0), ye(e._rangeEncoder, e._isRep0Long, n, 1 == a ? 0 : 1)), 1 == a ? e._state = e._state < 7 ? 9 : 11 : (me(e._repMatchLenEncoder, e._rangeEncoder, a - 2, m), e._state = e._state < 7 ? 8 : 11), i = e._repDistances[u], 0 != u) {
                            for (_ = u; 1 <= _; --_) e._repDistances[_] = e._repDistances[_ - 1];
                            e._repDistances[0] = i
                        }
                    } else {
                        for (ye(e._rangeEncoder, e._isRep, e._state, 0), e._state = e._state < 7 ? 7 : 10, me(e._lenEncoder, e._rangeEncoder, a - 2, m), f = ce(u -= 4), p = Z(a), Re(e._posSlotEncoder[p], e._rangeEncoder, f), 4 <= f && (p = u - (n = (2 | 1 & f) << (c = (f >> 1) - 1)), f < 14 ? function(e, r, t, o, n) {
                                var s, i, _ = 1;
                                for (i = 0; i < o; ++i) ye(t, e, r + _, s = 1 & n), _ = _ << 1 | s, n >>= 1
                            }(e._posEncoders, n - f - 1, e._rangeEncoder, c, p) : (Ce(e._rangeEncoder, p >> 4, c - 4), De(e._posAlignEncoder, e._rangeEncoder, 15 & p), ++e._alignPriceCount)), i = u, _ = 3; 1 <= _; --_) e._repDistances[_] = e._repDistances[_ - 1];
                        e._repDistances[0] = i, ++e._matchPriceCount
                    }
                    e._previousByte = V(e._matchFinder, a - 1 - e._additionalOffset)
                }
                if (e._additionalOffset -= a, e.nowPos64 = l(e.nowPos64, S(a)), !e._additionalOffset) {
                    if (128 <= e._matchPriceCount && te(e), 16 <= e._alignPriceCount && re(e), r[0] = e.nowPos64, t[0] = function(e) {
                            return l(l(S(e._cacheSize), e._position), [4, 0])
                        }(e._rangeEncoder), !$(e._matchFinder)) return oe(e, g(e.nowPos64));
                    if (0 <= v(k(e.nowPos64, d), [4096, 0])) return e._finished = 0, o[0] = 0
                }
            }
        }((r = e).encoder, r.encoder.processedInSize, r.encoder.processedOutSize, r.encoder.finished), r.inBytesProcessed = r.encoder.processedInSize[0], r.encoder.finished[0] && (function(e) {
            ae(e), e._rangeEncoder.Stream = null
        }(r.encoder), r.alive = 0)) : function(e) {
            var r = function(e) {
                var r, t, o;
                if (o = g(e.nowPos64) & e.m_PosStateMask, be(e.m_RangeDecoder, e.m_IsMatchDecoders, (e.state << 4) + o)) {
                    if (be(e.m_RangeDecoder, e.m_IsRepDecoders, e.state)) r = 0, be(e.m_RangeDecoder, e.m_IsRepG0Decoders, e.state) ? (be(e.m_RangeDecoder, e.m_IsRepG1Decoders, e.state) ? (be(e.m_RangeDecoder, e.m_IsRepG2Decoders, e.state) ? (t = e.rep3, e.rep3 = e.rep2) : t = e.rep2, e.rep2 = e.rep1) : t = e.rep1, e.rep1 = e.rep0, e.rep0 = t) : be(e.m_RangeDecoder, e.m_IsRep0LongDecoders, (e.state << 4) + o) || (e.state = e.state < 7 ? 9 : 11, r = 1), r || (r = J(e.m_RepLenDecoder, e.m_RangeDecoder, o) + 2, e.state = e.state < 7 ? 8 : 11);
                    else if (e.rep3 = e.rep2, e.rep2 = e.rep1, e.rep1 = e.rep0, r = 2 + J(e.m_LenDecoder, e.m_RangeDecoder, o), e.state = e.state < 7 ? 7 : 10, 4 <= (t = ge(e.m_PosSlotDecoder[Z(r)], e.m_RangeDecoder))) {
                        if (o = (t >> 1) - 1, e.rep0 = (2 | 1 & t) << o, t < 14) e.rep0 += function(e, r, t, o) {
                            var n, s, i = 1,
                                _ = 0;
                            for (s = 0; s < o; ++s) n = be(t, e, r + i), i <<= 1, i += n, _ |= n << s;
                            return _
                        }(e.m_PosDecoders, e.rep0 - t - 1, e.m_RangeDecoder, o);
                        else if (e.rep0 += function(e, r) {
                                var t, o, n = 0;
                                for (t = r; 0 != t; --t) e.Range >>>= 1, o = e.Code - e.Range >>> 31, e.Code -= e.Range & o - 1, n = n << 1 | 1 - o, -16777216 & e.Range || (e.Code = e.Code << 8 | R(e.Stream), e.Range <<= 8);
                                return n
                            }(e.m_RangeDecoder, o - 4) << 4, e.rep0 += function(e, r) {
                                var t, o, n = 1,
                                    s = 0;
                                for (o = 0; o < e.NumBitLevels; ++o) t = be(r, e.Models, n), n <<= 1, n += t, s |= t << o;
                                return s
                            }(e.m_PosAlignDecoder, e.m_RangeDecoder), e.rep0 < 0) return -1 == e.rep0 ? 1 : -1
                    } else e.rep0 = t;
                    if (0 <= v(S(e.rep0), e.nowPos64) || e.rep0 >= e.m_DictionarySizeCheck) return -1;
                    ! function(e, r, t) {
                        var o = e._pos - r - 1;
                        for (o < 0 && (o += e._windowSize); 0 != t; --t) o >= e._windowSize && (o = 0), e._buffer[e._pos++] = e._buffer[o++], e._pos >= e._windowSize && G(e)
                    }(e.m_OutWindow, e.rep0, r), e.nowPos64 = l(e.nowPos64, S(r)), e.prevByte = W(e.m_OutWindow, 0)
                } else r = function(e, r, t) {
                        return e.m_Coders[((r & e.m_PosMask) << e.m_NumPrevBits) + ((255 & t) >>> 8 - e.m_NumPrevBits)]
                    }(e.m_LiteralDecoder, g(e.nowPos64), e.prevByte), e.state < 7 ? e.prevByte = function(e, r) {
                        var t = 1;
                        for (; t = t << 1 | be(r, e.m_Decoders, t), t < 256;);
                        return t << 24 >> 24
                    }(r, e.m_RangeDecoder) : e.prevByte = function(e, r, t) {
                        var o, n, s = 1;
                        do {
                            if (n = t >> 7 & 1, t <<= 1, o = be(r, e.m_Decoders, (1 + n << 8) + s), s = s << 1 | o, n != o) {
                                for (; s < 256;) s = s << 1 | be(r, e.m_Decoders, s);
                                break
                            }
                        } while (s < 256);
                        return s << 24 >> 24
                    }(r, e.m_RangeDecoder, W(e.m_OutWindow, e.rep0)),
                    function(e, r) {
                        e._buffer[e._pos++] = r, e._pos >= e._windowSize && G(e)
                    }(e.m_OutWindow, e.prevByte), e.state = K(e.state), e.nowPos64 = l(e.nowPos64, P);
                return 0
            }(e.decoder);
            if (-1 == r) throw new Error("corrupted input");
            e.inBytesProcessed = c, e.outBytesProcessed = e.decoder.nowPos64, (r || 0 <= v(e.decoder.outSize, h) && 0 <= v(e.decoder.nowPos64, e.decoder.outSize)) && (G(e.decoder.m_OutWindow), T(e.decoder.m_OutWindow), e.decoder.m_RangeDecoder.Stream = null, e.alive = 0)
        }(e), e.alive
    }

    function q(e, r) {
        for (; e.m_NumPosStates < r; ++e.m_NumPosStates) e.m_LowCoder[e.m_NumPosStates] = Se({}, 3), e.m_MidCoder[e.m_NumPosStates] = Se({}, 3)
    }

    function J(e, r, t) {
        if (!be(r, e.m_Choice, 0)) return ge(e.m_LowCoder[t], r);
        var o = 8;
        return be(r, e.m_Choice, 1) ? o += 8 + ge(e.m_HighCoder, r) : o += ge(e.m_MidCoder[t], r), o
    }

    function Q(e) {
        return e.m_Choice = m(2), e.m_LowCoder = m(16), e.m_MidCoder = m(16), e.m_HighCoder = Se({}, 8), e.m_NumPosStates = 0, e
    }

    function U(e) {
        we(e.m_Choice);
        for (var r = 0; r < e.m_NumPosStates; ++r) we(e.m_LowCoder[r].Models), we(e.m_MidCoder[r].Models);
        we(e.m_HighCoder.Models)
    }
    var X = function() {
        for (var e, r, t = 2, o = [0, 1], n = 2; n < 22; ++n)
            for (r = 1 << (n >> 1) - 1, e = 0; e < r; ++e, ++t) o[t] = n << 24 >> 24;
        return o
    }();

    function ee(e, r) {
        var t, o, n, s;
        for (e._optimumEndIndex = r, n = e._optimum[r].PosPrev, o = e._optimum[r].BackPrev; e._optimum[r].Prev1IsChar && (Be(e._optimum[n]), e._optimum[n].PosPrev = n - 1, e._optimum[r].Prev2 && (e._optimum[n - 1].Prev1IsChar = 0, e._optimum[n - 1].PosPrev = e._optimum[r].PosPrev2, e._optimum[n - 1].BackPrev = e._optimum[r].BackPrev2)), s = n, t = o, o = e._optimum[s].BackPrev, n = e._optimum[s].PosPrev, e._optimum[s].BackPrev = t, e._optimum[s].PosPrev = r, 0 < (r = s););
        return e.backRes = e._optimum[0].BackPrev, e._optimumCurrentIndex = e._optimum[0].PosPrev, e._optimumCurrentIndex
    }

    function re(e) {
        for (var r = 0; r < 16; ++r) e._alignPrices[r] = function(e, r) {
            var t, o, n = 1,
                s = 0;
            for (o = e.NumBitLevels; 0 != o; --o) t = 1 & r, r >>>= 1, s += ze(e.Models[n], t), n = n << 1 | t;
            return s
        }(e._posAlignEncoder, r);
        e._alignPriceCount = 0
    }

    function te(e) {
        for (var r, t, o, n, s, i, _, a = 4; a < 128; ++a) r = (2 | 1 & (s = ce(a))) << (o = (s >> 1) - 1), e.tempPrices[a] = function(e, r, t, o) {
            var n, s, i = 1,
                _ = 0;
            for (s = t; 0 != s; --s) n = 1 & o, o >>>= 1, _ += Ee[(2047 & (e[r + i] - n ^ -n)) >>> 2], i = i << 1 | n;
            return _
        }(e._posEncoders, r - s - 1, o, a - r);
        for (n = 0; n < 4; ++n) {
            for (t = e._posSlotEncoder[n], i = n << 6, s = 0; s < e._distTableSize; ++s) e._posSlotPrices[i + s] = Me(t, s);
            for (s = 14; s < e._distTableSize; ++s) e._posSlotPrices[i + s] += (s >> 1) - 1 - 4 << 6;
            for (_ = 128 * n, a = 0; a < 4; ++a) e._distancesPrices[_ + a] = e._posSlotPrices[i + a];
            for (; a < 128; ++a) e._distancesPrices[_ + a] = e._posSlotPrices[i + ce(a)] + e.tempPrices[a]
        }
        e._matchPriceCount = 0
    }

    function oe(e, r) {
        ae(e),
            function(e, r) {
                if (!e._writeEndMark) return;
                ye(e._rangeEncoder, e._isMatch, (e._state << 4) + r, 1), ye(e._rangeEncoder, e._isRep, e._state, 0), e._state = e._state < 7 ? 7 : 10, me(e._lenEncoder, e._rangeEncoder, 0, r);
                r = Z(2);
                Re(e._posSlotEncoder[r], e._rangeEncoder, 63), Ce(e._rangeEncoder, 67108863, 26), De(e._posAlignEncoder, e._rangeEncoder, 15)
            }(e, r & e._posStateMask);
        for (var t = 0; t < 5; ++t) Le(e._rangeEncoder)
    }

    function ne(e, r, t, o) {
        var n = Z(t),
            r = r < 128 ? e._distancesPrices[128 * n + r] : e._posSlotPrices[(n << 6) + function(e) {
                if (e < 131072) return X[e >> 6] + 12;
                if (e < 134217728) return X[e >> 16] + 32;
                return X[e >> 26] + 52
            }(r)] + e._alignPrices[15 & r];
        return r + pe(e._lenEncoder, t - 2, o)
    }

    function se(e, r, t, o) {
        var n;
        return r ? (n = Ee[2048 - e._isRepG0[t] >>> 2], 1 == r ? n += Ee[e._isRepG1[t] >>> 2] : (n += Ee[2048 - e._isRepG1[t] >>> 2], n += ze(e._isRepG2[t], r - 2))) : (n = Ee[e._isRepG0[t] >>> 2], n += Ee[2048 - e._isRep0Long[(t << 4) + o] >>> 2]), n
    }

    function ie(e, r) {
        0 < r && (function(e, r) {
            var t, o, n, s, i, _, a, c, u, f, m, d, p, h;
            do {
                if (e._pos + e._matchMaxLen <= e._streamPos) u = e._matchMaxLen;
                else if ((u = e._streamPos - e._pos) < e.kMinMatchCheck) {
                    A(e);
                    continue
                }
                for (f = e._pos > e._cyclicBufferSize ? e._pos - e._cyclicBufferSize : 0, o = e._bufferOffset + e._pos, h = e.HASH_ARRAY ? (i = 1023 & (h = O[255 & e._bufferBase[o]] ^ 255 & e._bufferBase[o + 1]), e._hash[i] = e._pos, i = 65535 & (h ^= (255 & e._bufferBase[o + 2]) << 8), e._hash[1024 + i] = e._pos, (h ^ O[255 & e._bufferBase[o + 3]] << 5) & e._hashMask) : 255 & e._bufferBase[o] ^ (255 & e._bufferBase[o + 1]) << 8, n = e._hash[e.kFixHashSize + h], e._hash[e.kFixHashSize + h] = e._pos, d = 1 + (e._cyclicBufferPos << 1), p = e._cyclicBufferPos << 1, a = c = e.kNumHashDirectBytes, t = e._cutValue;;) {
                    if (n <= f || 0 == t--) {
                        e._son[d] = e._son[p] = 0;
                        break
                    }
                    if (s = ((s = e._pos - n) <= e._cyclicBufferPos ? e._cyclicBufferPos - s : e._cyclicBufferPos - s + e._cyclicBufferSize) << 1, m = e._bufferOffset + n, _ = a < c ? a : c, e._bufferBase[m + _] == e._bufferBase[o + _]) {
                        for (; ++_ != u && e._bufferBase[m + _] == e._bufferBase[o + _];);
                        if (_ == u) {
                            e._son[p] = e._son[s], e._son[d] = e._son[1 + s];
                            break
                        }
                    }(255 & e._bufferBase[m + _]) < (255 & e._bufferBase[o + _]) ? (e._son[p] = n, p = 1 + s, n = e._son[p], c = _) : (e._son[d] = n, d = s, n = e._son[d], a = _)
                }
                A(e)
            } while (0 != --r)
        }(e._matchFinder, r), e._additionalOffset += r)
    }

    function _e(e) {
        var r = 0;
        return e._numDistancePairs = function(e, r) {
            var t, o, n, s, i, _, a, c, u, f, m, d, p, h, P, l, v, B, S, g;
            if (e._pos + e._matchMaxLen <= e._streamPos) p = e._matchMaxLen;
            else if ((p = e._streamPos - e._pos) < e.kMinMatchCheck) return A(e), 0;
            for (l = 0, h = e._pos > e._cyclicBufferSize ? e._pos - e._cyclicBufferSize : 0, o = e._bufferOffset + e._pos, P = 1, c = a = 0, u = e.HASH_ARRAY ? (a = 1023 & (g = O[255 & e._bufferBase[o]] ^ 255 & e._bufferBase[o + 1]), c = 65535 & (g ^= (255 & e._bufferBase[o + 2]) << 8), (g ^ O[255 & e._bufferBase[o + 3]] << 5) & e._hashMask) : 255 & e._bufferBase[o] ^ (255 & e._bufferBase[o + 1]) << 8, n = e._hash[e.kFixHashSize + u] || 0, e.HASH_ARRAY && (s = e._hash[a] || 0, g = e._hash[1024 + c] || 0, e._hash[a] = e._pos, e._hash[1024 + c] = e._pos, h < s && e._bufferBase[e._bufferOffset + s] == e._bufferBase[o] && (r[l++] = P = 2, r[l++] = e._pos - s - 1), h < g && e._bufferBase[e._bufferOffset + g] == e._bufferBase[o] && (g == s && (l -= 2), r[l++] = P = 3, r[l++] = e._pos - g - 1, s = g), 0 != l && s == n && (l -= 2, P = 1)), e._hash[e.kFixHashSize + u] = e._pos, B = 1 + (e._cyclicBufferPos << 1), S = e._cyclicBufferPos << 1, m = d = e.kNumHashDirectBytes, 0 != e.kNumHashDirectBytes && h < n && e._bufferBase[e._bufferOffset + n + e.kNumHashDirectBytes] != e._bufferBase[o + e.kNumHashDirectBytes] && (r[l++] = P = e.kNumHashDirectBytes, r[l++] = e._pos - n - 1), t = e._cutValue;;) {
                if (n <= h || 0 == t--) {
                    e._son[B] = e._son[S] = 0;
                    break
                }
                if (i = ((_ = e._pos - n) <= e._cyclicBufferPos ? e._cyclicBufferPos - _ : e._cyclicBufferPos - _ + e._cyclicBufferSize) << 1, v = e._bufferOffset + n, f = m < d ? m : d, e._bufferBase[v + f] == e._bufferBase[o + f]) {
                    for (; ++f != p && e._bufferBase[v + f] == e._bufferBase[o + f];);
                    if (P < f && (r[l++] = P = f, r[l++] = _ - 1, f == p)) {
                        e._son[S] = e._son[i], e._son[B] = e._son[1 + i];
                        break
                    }
                }(255 & e._bufferBase[v + f]) < (255 & e._bufferBase[o + f]) ? (e._son[S] = n, S = 1 + i, n = e._son[S], d = f) : (e._son[B] = n, B = i, n = e._son[B], m = f)
            }
            return A(e), l
        }(e._matchFinder, e._matchDistances), 0 < e._numDistancePairs && (r = e._matchDistances[e._numDistancePairs - 2]) == e._numFastBytes && (r += j(e._matchFinder, r - 1, e._matchDistances[e._numDistancePairs - 1], 273 - r)), ++e._additionalOffset, r
    }

    function ae(e) {
        e._matchFinder && e._needReleaseMFStream && (e._matchFinder._stream = null, e._needReleaseMFStream = 0)
    }

    function ce(e) {
        return e < 2048 ? X[e] : e < 2097152 ? X[e >> 10] + 20 : X[e >> 20] + 40
    }

    function ue(e, r) {
        we(e._choice);
        for (var t = 0; t < r; ++t) we(e._lowCoder[t].Models), we(e._midCoder[t].Models);
        we(e._highCoder.Models)
    }

    function fe(e, r, t, o, n) {
        var s = Ee[e._choice[0] >>> 2],
            i = Ee[2048 - e._choice[0] >>> 2],
            _ = i + Ee[e._choice[1] >>> 2],
            a = i + Ee[2048 - e._choice[1] >>> 2],
            c = 0;
        for (c = 0; c < 8; ++c) {
            if (t <= c) return;
            o[n + c] = s + Me(e._lowCoder[r], c)
        }
        for (; c < 16; ++c) {
            if (t <= c) return;
            o[n + c] = _ + Me(e._midCoder[r], c - 8)
        }
        for (; c < t; ++c) o[n + c] = a + Me(e._highCoder, c - 8 - 8)
    }

    function me(e, r, t, o) {
        var n, s;
        n = e, s = r, r = o, (t = t) < 8 ? (ye(s, n._choice, 0, 0), Re(n._lowCoder[r], s, t)) : (t -= 8, ye(s, n._choice, 0, 1), t < 8 ? (ye(s, n._choice, 1, 0), Re(n._midCoder[r], s, t)) : (ye(s, n._choice, 1, 1), Re(n._highCoder, s, t - 8))), 0 == --e._counters[o] && (fe(e, o, e._tableSize, e._prices, 272 * o), e._counters[o] = e._tableSize)
    }

    function de(e) {
        return function(e) {
            e._choice = m(2), e._lowCoder = m(16), e._midCoder = m(16), e._highCoder = ke({}, 8);
            for (var r = 0; r < 16; ++r) e._lowCoder[r] = ke({}, 3), e._midCoder[r] = ke({}, 3)
        }(e), e._prices = [], e._counters = [], e
    }

    function pe(e, r, t) {
        return e._prices[272 * t + r]
    }

    function he(e, r) {
        for (var t = 0; t < r; ++t) fe(e, t, e._tableSize, e._prices, 272 * t), e._counters[t] = e._tableSize
    }

    function Pe(e, r, t) {
        return e.m_Coders[((r & e.m_PosMask) << e.m_NumPrevBits) + ((255 & t) >>> 8 - e.m_NumPrevBits)]
    }

    function le(e, r, t) {
        for (var o, n = 1, s = 7; 0 <= s; --s) o = t >> s & 1, ye(r, e.m_Encoders, n, o), n = n << 1 | o
    }

    function ve(e, r, t, o) {
        var n, s, i = 1,
            _ = 7,
            a = 0;
        if (r)
            for (; 0 <= _; --_)
                if (s = t >> _ & 1, n = o >> _ & 1, a += ze(e.m_Encoders[(1 + s << 8) + i], n), i = i << 1 | n, s != n) {
                    --_;
                    break
                }
        for (; 0 <= _; --_) n = o >> _ & 1, a += ze(e.m_Encoders[i], n), i = i << 1 | n;
        return a
    }

    function Be(e) {
        e.BackPrev = -1, e.Prev1IsChar = 0
    }

    function Se(e, r) {
        return e.NumBitLevels = r, e.Models = m(1 << r), e
    }

    function ge(e, r) {
        for (var t = 1, o = e.NumBitLevels; 0 != o; --o) t = (t << 1) + be(r, e.Models, t);
        return t - (1 << e.NumBitLevels)
    }

    function ke(e, r) {
        return e.NumBitLevels = r, e.Models = m(1 << r), e
    }

    function Re(e, r, t) {
        for (var o, n = 1, s = e.NumBitLevels; 0 != s;) o = t >>> --s & 1, ye(r, e.Models, n, o), n = n << 1 | o
    }

    function Me(e, r) {
        for (var t, o = 1, n = 0, s = e.NumBitLevels; 0 != s;) t = r >>> --s & 1, n += ze(e.Models[o], t), o = (o << 1) + t;
        return n
    }

    function De(e, r, t) {
        for (var o, n = 1, s = 0; s < e.NumBitLevels; ++s) o = 1 & t, ye(r, e.Models, n, o), n = n << 1 | o, t >>= 1
    }

    function be(e, r, t) {
        var o = r[t],
            n = (e.Range >>> 11) * o;
        return (-2147483648 ^ e.Code) < (-2147483648 ^ n) ? (e.Range = n, r[t] = o + (2048 - o >>> 5) << 16 >> 16, -16777216 & e.Range || (e.Code = e.Code << 8 | R(e.Stream), e.Range <<= 8), 0) : (e.Range -= n, e.Code -= n, r[t] = o - (o >>> 5) << 16 >> 16, -16777216 & e.Range || (e.Code = e.Code << 8 | R(e.Stream), e.Range <<= 8), 1)
    }

    function we(e) {
        for (var r = e.length - 1; 0 <= r; --r) e[r] = 1024
    }
    var Ee = function() {
        for (var e, r, t = [], o = 8; 0 <= o; --o)
            for (e = 1 << 9 - o, r = 1 << 9 - o - 1; r < e; ++r) t[r] = (o << 6) + (e - r << 6 >>> 9 - o - 1);
        return t
    }();

    function ye(e, r, t, o) {
        var n = r[t],
            s = (e.Range >>> 11) * n;
        o ? (e.Low = l(e.Low, i(S(s), [4294967295, 0])), e.Range -= s, r[t] = n - (n >>> 5) << 16 >> 16) : (e.Range = s, r[t] = n + (2048 - n >>> 5) << 16 >> 16), -16777216 & e.Range || (e.Range <<= 8, Le(e))
    }

    function Ce(e, r, t) {
        for (var o = t - 1; 0 <= o; --o) e.Range >>>= 1, 1 == (r >>> o & 1) && (e.Low = l(e.Low, S(e.Range))), -16777216 & e.Range || (e.Range <<= 8, Le(e))
    }

    function Le(e) {
        var r, t, o, n, s = g((t = e.Low, o = 32, n = d(t, o &= 63), t[1] < 0 && (n = l(n, a([2, 0], 63 - o))), n));
        if (0 != s || v(e.Low, [4278190080, 0]) < 0) {
            for (e._position = l(e._position, S(e._cacheSize)), r = e._cache; b(e.Stream, r + s), r = 255, 0 != --e._cacheSize;);
            e._cache = g(e.Low) >>> 24
        }++e._cacheSize, e.Low = a(i(e.Low, [16777215, 0]), 8)
    }

    function ze(e, r) {
        return Ee[(2047 & (e - r ^ -r)) >>> 2]
    }

    function Fe(e) {
        for (var r, t, o, n = 0, s = 0, i = e.length, _ = [], a = []; n < i; ++n, ++s) {
            if (128 & (r = 255 & e[n]))
                if (192 == (224 & r)) {
                    if (i <= n + 1) return e;
                    if (128 != (192 & (t = 255 & e[++n]))) return e;
                    a[s] = (31 & r) << 6 | 63 & t
                } else {
                    if (224 != (240 & r)) return e;
                    if (i <= n + 2) return e;
                    if (128 != (192 & (t = 255 & e[++n]))) return e;
                    if (128 != (192 & (o = 255 & e[++n]))) return e;
                    a[s] = (15 & r) << 12 | (63 & t) << 6 | 63 & o
                }
            else {
                if (!r) return e;
                a[s] = r
            }
            16383 == s && (_.push(String.fromCharCode.apply(String, a)), s = -1)
        }
        return 0 < s && (a.length = s, _.push(String.fromCharCode.apply(String, a))), _.join("")
    }

    function Ie(e) {
        var r, t, o, n = [],
            s = 0,
            i = e.length;
        if ("object" == typeof e) return e;
        for (! function(e, r, t, o, n) {
                for (var s = r; s < t; ++s) o[n++] = e.charCodeAt(s)
            }(e, 0, i, n, 0), o = 0; o < i; ++o) 1 <= (r = n[o]) && r <= 127 ? ++s : s += !r || 128 <= r && r <= 2047 ? 2 : 3;
        for (t = [], o = s = 0; o < i; ++o) 1 <= (r = n[o]) && r <= 127 ? t[s++] = r << 24 >> 24 : (!r || 128 <= r && r <= 2047 ? t[s++] = (192 | r >> 6 & 31) << 24 >> 24 : (t[s++] = (224 | r >> 12 & 15) << 24 >> 24, t[s++] = (128 | r >> 6 & 63) << 24 >> 24), t[s++] = (128 | 63 & r) << 24 >> 24);
        return t
    }

    function xe(e) {
        return e[1] + e[0]
    }
    var r, Ne = (r = [{
        s: 16,
        f: 64,
        m: 0
    }, {
        s: 20,
        f: 64,
        m: 0
    }, {
        s: 19,
        f: 64,
        m: 1
    }, {
        s: 20,
        f: 64,
        m: 1
    }, {
        s: 21,
        f: 128,
        m: 1
    }, {
        s: 22,
        f: 128,
        m: 1
    }, {
        s: 23,
        f: 128,
        m: 1
    }, {
        s: 24,
        f: 255,
        m: 1
    }, {
        s: 25,
        f: 255,
        m: 1
    }], function(e) {
        return r[e - 1] || r[6]
    });
    return "undefined" == typeof onmessage || "undefined" != typeof window && void 0 !== window.document || (onmessage = function(e) {
        e && e.data && (2 == e.data.action ? LZMA.decompress(e.data.data, e.data.cbn) : 1 == e.data.action && LZMA.compress(e.data.data, e.data.mode, e.data.cbn))
    }), {
        compress: function(e, r, o, n) {
            var s, t, i = {},
                _ = void 0 === o && void 0 === n;
            if ("function" != typeof o && (t = o, o = n = 0), n = n || function(e) {
                    if (void 0 !== t) return f(e, t)
                }, o = o || function(e, r) {
                    if (void 0 !== t) return postMessage({
                        action: 1,
                        cbn: t,
                        result: e,
                        error: r
                    })
                }, _) {
                for (i.c = L({}, Ie(e), Ne(r)); Y(i.c.chunker););
                return D(i.c.output)
            }
            try {
                i.c = L({}, Ie(e), Ne(r)), n(0)
            } catch (e) {
                return o(null, e)
            }
            u(function e() {
                try {
                    for (var r, t = (new Date).getTime(); Y(i.c.chunker);)
                        if (s = xe(i.c.chunker.inBytesProcessed) / xe(i.c.length_0), 200 < (new Date).getTime() - t) return n(s), u(e, 0), 0;
                    n(1), r = D(i.c.output), u(o.bind(null, r), 0)
                } catch (e) {
                    o(null, e)
                }
            }, 0)
        },
        decompress: function(e, n, s) {
            var i, t, _, a, c = {},
                r = void 0 === n && void 0 === s;
            if ("function" != typeof n && (t = n, n = s = 0), s = s || function(e) {
                    if (void 0 !== t) return f(_ ? e : -1, t)
                }, n = n || function(e, r) {
                    if (void 0 !== t) return postMessage({
                        action: 2,
                        cbn: t,
                        result: e,
                        error: r
                    })
                }, r) {
                for (c.d = F({}, e); Y(c.d.chunker););
                return Fe(D(c.d.output))
            }
            try {
                c.d = F({}, e), a = xe(c.d.length_0), _ = -1 < a, s(0)
            } catch (e) {
                return n(null, e)
            }
            u(function e() {
                try {
                    for (var r, t = 0, o = (new Date).getTime(); Y(c.d.chunker);)
                        if (++t % 1e3 == 0 && 200 < (new Date).getTime() - o) return _ && (i = xe(c.d.chunker.decoder.nowPos64) / a, s(i)), u(e, 0), 0;
                    s(1), r = Fe(D(c.d.output)), u(n.bind(null, r), 0)
                } catch (e) {
                    n(null, e)
                }
            }, 0)
        }
    }
}();
this.LZMA = this.LZMA_WORKER = LZMA;